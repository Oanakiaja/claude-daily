use anyhow::Result;
use chrono::{Local, Timelike};
use std::fs;
use std::process::{Command, Stdio};

use crate::archive::ArchiveManager;
use crate::config::load_config;
use crate::hooks::read_hook_input;

/// Handle SessionStart hook from Claude Code
/// Creates today's directory if it doesn't exist and initializes daily.md
pub async fn handle() -> Result<()> {
    let config = load_config()?;

    // Check if hooks are enabled
    if !config.hooks.enable_session_start {
        return Ok(());
    }

    // Try to read hook input, but don't fail if not available
    // (allows manual testing without stdin)
    let _input = read_hook_input().ok();

    let today = Local::now().format("%Y-%m-%d").to_string();
    let daily_dir = config.today_dir();

    // Create today's directory if first session of the day
    if !daily_dir.exists() {
        fs::create_dir_all(&daily_dir)?;

        // Initialize daily.md with frontmatter
        let daily_md = daily_dir.join("daily.md");
        let now = Local::now();
        let content = format!(
            r#"---
date: {}
created: {}
updated: {}
tags: [daily-summary, claude-code]
sessions: []
total_sessions: 0
---

# Daily Summary - {}

## Overview

_No sessions archived yet._

## Sessions

## Key Insights

## Skills & Commands Identified

## Reflections

---
*Generated by Daily Context Archive System*
"#,
            today,
            now.to_rfc3339(),
            now.to_rfc3339(),
            today
        );
        fs::write(&daily_md, content)?;

        eprintln!("[daily] Created daily directory: {}", daily_dir.display());
    }

    // Check for auto-digest of previous day's sessions
    if config.summarization.auto_digest_enabled {
        check_auto_digest(&config);
    }

    // Check for pending skills to review
    check_pending_skills(&config);

    // Exit with 0 to allow session to continue
    Ok(())
}

/// Check if we should auto-digest yesterday's sessions
fn check_auto_digest(config: &crate::config::Config) {
    // Parse digest_time (format: "HH:MM")
    let digest_time = &config.summarization.digest_time;
    let parts: Vec<&str> = digest_time.split(':').collect();
    if parts.len() != 2 {
        return;
    }

    let (digest_hour, digest_minute) = match (parts[0].parse::<u32>(), parts[1].parse::<u32>()) {
        (Ok(h), Ok(m)) if h < 24 && m < 60 => (h, m),
        _ => return,
    };

    let now = Local::now();
    let current_minutes = now.hour() * 60 + now.minute();
    let digest_minutes = digest_hour * 60 + digest_minute;

    // Only trigger if we're past digest time
    if current_minutes < digest_minutes {
        return;
    }

    // Get yesterday's date
    let yesterday = (now - chrono::Duration::days(1))
        .format("%Y-%m-%d")
        .to_string();

    // Check if yesterday has un-digested sessions
    let manager = ArchiveManager::new(config.clone());
    if !manager.has_sessions(&yesterday) {
        return;
    }

    eprintln!(
        "[daily] Auto-digesting yesterday's sessions ({})...",
        yesterday
    );

    // Spawn background digest process
    if let Ok(exe) = std::env::current_exe() {
        let _ = Command::new(&exe)
            .args(["digest", "--date", &yesterday, "--foreground"])
            .stdin(Stdio::null())
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .spawn();
    }
}

/// Check for pending skills that need user review
fn check_pending_skills(config: &crate::config::Config) {
    let pending_dir = config.storage.path.join("pending-skills");

    if !pending_dir.exists() {
        return;
    }

    // Count pending skills across all dates
    let mut pending_skills: Vec<(String, String)> = Vec::new();

    if let Ok(entries) = fs::read_dir(&pending_dir) {
        for entry in entries.flatten() {
            if entry.path().is_dir() {
                if let Ok(files) = fs::read_dir(entry.path()) {
                    for file in files.flatten() {
                        if file.path().extension().map_or(false, |e| e == "md") {
                            let date = entry.file_name().to_string_lossy().to_string();
                            let name = file
                                .path()
                                .file_stem()
                                .map(|s| s.to_string_lossy().to_string())
                                .unwrap_or_default();
                            pending_skills.push((date, name));
                        }
                    }
                }
            }
        }
    }

    if pending_skills.is_empty() {
        return;
    }

    eprintln!();
    eprintln!("[daily] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    eprintln!("[daily] {} pending skill(s) waiting for review:", pending_skills.len());
    for (date, name) in pending_skills.iter().take(5) {
        eprintln!("[daily]   • {}/{}", date, name);
    }
    if pending_skills.len() > 5 {
        eprintln!("[daily]   ... and {} more", pending_skills.len() - 5);
    }
    eprintln!("[daily]");
    eprintln!("[daily] Review with: daily review-skills");
    eprintln!("[daily] Or ask Claude: \"review my pending skills\"");
    eprintln!("[daily] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━");
    eprintln!();
}
